use crate::pipeline::expression::execution::{Expression, ExpressionExecutor};
use anyhow::Context;
use dozer_core::state::StateStore;
use dozer_types::types::Record;
use uuid::Uuid;

pub enum PrimaryIndexDefinition {
    AutoGenerated,
    FieldBased(Vec<usize>),
}

pub struct SecondaryIndexDefinition {
    id: u16,
    expr: Expression,
}

pub fn store_record_with_indexes(
    store: &mut dyn StateStore,
    rec: Record,
    primary_idx: PrimaryIndexDefinition,
    secondary_indexes: Vec<SecondaryIndexDefinition>,
) -> anyhow::Result<()> {
    let primary_key = match primary_idx {
        PrimaryIndexDefinition::AutoGenerated => Uuid::new_v4().as_u128().to_ne_bytes(),
        PrimaryIndexDefinition::FieldBased(indexes) => {
            rec.get_key(&indexes, Some(&0_u16.to_ne_bytes()))?
        }
    };
    let value = bincode::serialize(&rec)?;
    store.put(&primary_key, value)?;

    for i in secondary_indexes {
        let mut idx_key = Vec::from(i.id.to_ne_bytes(), i.expr.evaluate(&rec).to_ne_bytes()?);
        store.put(idx_key.as_slice(), &primary_key);
    }
    Ok(())
}

pub fn delete_record_with_indexes(
    store: &mut dyn StateStore,
    rec: Record,
    primary_idx: FieldsIndexConfig,
    secondary_indexes: Vec<FieldsIndexConfig>,
) -> anyhow::Result<()> {
    for idx_config in secondary_indexes {
        let key = rec.get_key(
            &idx_config.field_indexes,
            Some(idx_config.identifier.to_ne_bytes().as_slice()),
        )?;
        store.del(key.as_slice())?;
    }
    let pk = rec.get_key(
        &primary_idx.field_indexes,
        Some(primary_idx.identifier.to_ne_bytes().as_slice()),
    )?;
    store.del(pk.as_slice())?;
    Ok(())
}

pub fn get_single_by_index(
    state: &mut dyn StateStore,
    key: &[u8],
) -> anyhow::Result<Option<Record>> {
    match state.get(key)? {
        Some(pk) => match state.get(pk)? {
            Some(buf) => Ok(Some(bincode::deserialize(buf)?)),
            _ => Err(anyhow!("Unable to find primary key {:x?}", pk)),
        },
        _ => Ok(None),
    }
}

pub fn get_multi_by_index(state: &mut dyn StateStore, key: &[u8]) -> anyhow::Result<Vec<Record>> {
    let mut records = Vec::<Record>::new();
    let mut cursor = state.cursor()?;
    if cursor.seek(key)? {
        loop {
            let kv = cursor.read()?;
            match kv {
                Some(t) => {
                    if t.0 != key {
                        break;
                    }
                    let payload = state
                        .get(t.1)?
                        .context(anyhow!("Unable to find record for primary key {:x?}", t.1))?;
                    let mut rec: Record = bincode::deserialize(payload)?;
                    records.push(rec);
                }
                _ => break,
            }
            if !cursor.next()? {
                break;
            }
        }
    }
    Ok(records)
}
