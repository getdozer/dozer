use dozer_types::schema_registry::{SchemaRegistry, SCHEMA_ADDR, SCHEMA_PORT};
use dozer_types::types::Schema;
use futures::{future, prelude::*};
use std::{net::SocketAddr, sync::Arc};
use tarpc::{
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};

use crate::storage::{RocksConfig, RocksStorage, Storage};

#[derive(Clone)]
pub struct SchemaRegistryServer {
    _addr: SocketAddr,
    storage_client: Arc<RocksStorage>,
}

#[tarpc::server]
impl SchemaRegistry for SchemaRegistryServer {
    async fn ping(self, _: tarpc::context::Context) -> String {
        "Pong".to_string()
    }
    async fn insert(self, _: tarpc::context::Context, schema: dozer_types::types::Schema) {
        let client = self.storage_client.clone();
        client.insert_schema(&schema);
    }

    async fn get(self, _: tarpc::context::Context, schema_id: u32) -> Schema {
        let client = self.storage_client.clone();
        client.get_schema(schema_id)
    }
}

pub async fn serve() -> anyhow::Result<()> {
    let server_addr = (SCHEMA_ADDR, SCHEMA_PORT);
    let storage_client = Arc::new(Storage::new(RocksConfig::default()));

    println!("Listening on Schema Registry");
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = SchemaRegistryServer {
                _addr: channel.transport().peer_addr().unwrap(),
                storage_client: Arc::clone(&storage_client),
            };
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
    Ok(())
}
