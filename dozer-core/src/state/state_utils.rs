use crate::state::StateStore;
use anyhow::{anyhow, Context};
use dozer_types::types::Record;

// pub enum PrimaryIndexDefinition {
//     AutoGenerated,
//     FieldBased(Vec<usize>),
// }
//
// pub struct SecondaryIndexDefinition {
//     id: u16,
//     expr: Express,
// }

// pub fn delete_record_with_indexes(
//     store: &mut dyn StateStore,
//     rec: Record,
//     primary_idx: FieldsIndexConfig,
//     secondary_indexes: Vec<FieldsIndexConfig>,
// ) -> anyhow::Result<()> {
//     for idx_config in secondary_indexes {
//         let key = rec.get_key(
//             &idx_config.field_indexes,
//             Some(idx_config.identifier.to_ne_bytes().as_slice()),
//         )?;
//         store.del(key.as_slice())?;
//     }
//     let pk = rec.get_key(
//         &primary_idx.field_indexes,
//         Some(primary_idx.identifier.to_ne_bytes().as_slice()),
//     )?;
//     store.del(pk.as_slice())?;
//     Ok(())
// }
//
// pub fn store_record_with_indexes(
//     store: &mut dyn StateStore,
//     rec: Record,
//     primary_idx: IndexDefinition,
//     secondary_indexes: Vec<FieldsIndexConfig>,
// ) -> anyhow::Result<()> {
//
//     match primary_idx {
//         IndexDefinition::FieldsBased()
//
//     }
//
//     let pk = rec
//         .get_key(
//             &primary_idx,
//             Some(primary_idx.identifier.to_ne_bytes().as_slice()),
//         )?
//         .as_slice();
//
//     for idx_config in secondary_indexes {
//         let key = rec.get_key(
//             &idx_config.field_indexes,
//             Some(idx_config.identifier.to_ne_bytes().as_slice()),
//         )?;
//         store.put(key.as_slice(), pk)?;
//     }
//
//     let payload = bincode::serialize(&rec)?;
//     store.put(pk, payload.as_slice())?;
//     Ok(())
// }
//
// pub fn get_single_by_index(
//     state: &mut dyn StateStore,
//     key: &[u8],
// ) -> anyhow::Result<Option<Record>> {
//     match state.get(key)? {
//         Some(pk) => match state.get(pk)? {
//             Some(buf) => Ok(Some(bincode::deserialize(buf)?)),
//             _ => Err(anyhow!("Unable to find primary key {:x?}", pk)),
//         },
//         _ => Ok(None),
//     }
// }

pub fn get_multi_by_index(state: &mut dyn StateStore, key: &[u8]) -> anyhow::Result<Vec<Record>> {
    let mut records = Vec::<Record>::new();
    let mut cursor = state.cursor()?;
    if cursor.seek(key)? {
        loop {
            let kv = cursor.read()?;
            match kv {
                Some(t) => {
                    if t.0 != key {
                        break;
                    }
                    let payload = state
                        .get(t.1)?
                        .context(anyhow!("Unable to find record for primary key {:x?}", t.1))?;
                    let mut rec: Record = bincode::deserialize(payload)?;
                    records.push(rec);
                }
                _ => break,
            }
            if !cursor.next()? {
                break;
            }
        }
    }
    Ok(records)
}
